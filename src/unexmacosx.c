/* src/unexmacosx.c -*- C -*-
 * Dump Emacs in Mach-O format for use on Mac OS X.
 * This version should be newer than the version in the directory above us.
 * Copyright (C) 2001-2014 Free Software Foundation, Inc. */
/*
This file is part of GNU Emacs.

GNU Emacs is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU Emacs is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.  */

/* Contributed by Andrew Choi <akochoi@mac.com>.  */

/* Documentation note.

   Consult the following documents/files for a description of the
   Mach-O format: the file loader.h, man pages for Mach-O and ld, old
   NEXTSTEP documents of the Mach-O format.  The tool otool dumps the
   mach header (-h option) and the load commands (-l option) in a
   Mach-O file.  The tool nm on Mac OS X displays the symbol table in
   a Mach-O file.  For examples of unexec for the Mach-O format, see
   the file unexnext.c in the GNU Emacs distribution, the file
   unexdyld.c in the Darwin port of GNU Emacs 20.7, and unexdyld.c in
   the Darwin port of XEmacs 21.1.  Also the Darwin Libc source
   contains the source code for malloc_freezedry and malloc_jumpstart.
   Read that to see what they do.  This file was written completely
   from scratch, making use of information from the above sources.  */

/* The Mac OS X implementation of unexec makes use of Darwin's `zone'
   memory allocator.  All calls to malloc, realloc, and free in Emacs
   are redirected to unexec_malloc, unexec_realloc, and unexec_free in
   this file.  When temacs is run, all memory requests are handled in
   the zone EmacsZone.  The Darwin memory allocator library calls
   maintain the data structures to manage this zone.  Dumping writes
   its contents to data segments of the executable file.  When emacs
   is run, the loader recreates the contents of the zone in memory.
   However since the initialization routine of the zone memory
   allocator is run again, this `zone' can no longer be used as a
   heap.  That is why emacs uses the ordinary malloc system call to
   allocate memory.  Also, when a block of memory needs to be
   reallocated and the new size is larger than the old one, a new
   block must be obtained by malloc and the old contents copied to
   it.  */

/* Peculiarity of the Mach-O files generated by ld in Mac OS X
   (possible causes of future bugs if changed).

   The file offset of the start of the __TEXT segment is zero.  Since
   the Mach header and load commands are located at the beginning of a
   Mach-O file, copying the contents of the __TEXT segment from the
   input file overwrites them in the output file.  Despite this,
   unexec works fine as written below because the segment load command
   for __TEXT appears, and is therefore processed, before all other
   load commands except the segment load command for __PAGEZERO, which
   remains unchanged.

   Although the file offset of the start of the __TEXT segment is
   zero, none of the sections it contains actually start there.  In
   fact, the earliest one starts a few hundred bytes beyond the end of
   the last load command.  The linker option -headerpad controls the
   minimum size of this padding.  Its setting can be changed in
   s/darwin.h.  A value of 0x690, e.g., leaves room for 30 additional
   load commands for the newly created __DATA segments (at 56 bytes
   each).  Unexec fails if there is not enough room for these new
   segments.

   The __TEXT segment contains the sections __text, __cstring,
   __picsymbol_stub, and __const and the __DATA segment contains the
   sections __data, __la_symbol_ptr, __nl_symbol_ptr, __dyld, __bss,
   and __common.  The other segments do not contain any sections.
   These sections are copied from the input file to the output file,
   except for __data, __bss, and __common, which are dumped from
   memory.  The types of the sections __bss and __common are changed
   from S_ZEROFILL to S_REGULAR.  Note that the number of sections and
   their relative order in the input and output files remain
   unchanged.  Otherwise all n_sect fields in the nlist records in the
   symbol table (specified by the LC_SYMTAB load command) will have to
   be changed accordingly.
*/

/* config.h #define:s malloc/realloc/free and then includes stdlib.h.
   We want the undefined versions, but if config.h includes stdlib.h
   with the #define:s in place, the prototypes will be wrong and we get
   warnings.  To prevent that, include stdlib.h before config.h.  */

#include <stdlib.h>
#include <config.h>
#undef malloc
#undef realloc
#undef free

#include "unexec.h"
#if defined(HAVE_STDALIGN_H) && defined(BUILDING_FROM_XCODE)
# undef HAVE_STDALIGN_H
#endif /* HAVE_STDALIGN_H && BUILDING_FROM_XCODE */
#include "lisp.h"

#if defined(emacs) || defined(temacs)
# include "sysstdio.h"
#else
# if defined(HAVE_STDIO_H) || defined(STDC_HEADERS) || defined(__STDC__)
#  include <stdio.h>
# else
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__) && defined(lint)
#   warning "src/unexmacosx.c expects <stdio.h> to be included."
#  endif /* __GNUC__ && !__STRICT_ANSI__ && lint */
# endif /* HAVE_STDIO_H || STDC_HEADERS || __STDC__ */
#endif /* emacs || temacs */
#ifdef HAVE_ERRNO_H
# include <errno.h>
#else
# if !defined(errno) && defined(__GNUC__) && !defined(__STRICT_ANSI__)
#  warning "src/unexmacosx.c expects <errno.h> to be included for errno."
# endif /* !errno && __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_ERRNO_H */
#include <fcntl.h>
#include <stdarg.h>
#include <sys/types.h>
#include <unistd.h>
#ifdef HAVE_LIBC_H
# include <libc.h>
#endif /* HAVE_LIBC_H */
#ifdef HAVE_LIMITS_H
# include <limits.h>
#else
# if !defined(UINT_MAX) && defined(__GNUC__) && !defined(__STRICT_ANSI__)
#  warning "src/unexmacosx.c wants to include <limits.h> for UINT_MAX."
# endif /* !UINT_MAX && __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_LIMITS_H */
#include <mach/mach.h>
#if !defined(NeXT) && defined(HAVE_MACH_MACHINE_VM_PARAM_H)
# include <mach/machine/vm_param.h>
#endif /* !NeXT && HAVE_MACH_MACHINE_VM_PARAM_H */
#ifdef HAVE_MACH_VM_REGION_H
# include <mach/vm_region.h>
#endif /* HAVE_MACH_VM_REGION_H */
#include <mach-o/arch.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#if defined(__ppc__)
# include <mach-o/ppc/reloc.h>
#endif /* __ppc__ */
#ifdef HAVE_MALLOC_MALLOC_H
# include <malloc/malloc.h>
#else
# include <objc/malloc.h>
#endif /* HAVE_MALLOC_MALLOC_H */

#include <assert.h>

#include <AvailabilityMacros.h>

/* LC_DATA_IN_CODE is not defined in mach-o/loader.h on OS X 10.7.
   But it is used if we build with "Command Line Tools for Xcode 4.5
   (OS X Lion) - September 2012".  */
#ifndef LC_DATA_IN_CODE
# if (MAC_OS_X_VERSION_MAX_ALLOWED > 1060) \
     || (MAC_OS_X_VERSION_MIN_REQUIRED > 1060)
#  define LC_DATA_IN_CODE 0x29 /* table of non-instructions in __text */
# endif /* 10.7+ */
#endif /* !LC_DATA_IN_CODE */

#ifdef _LP64
# define mach_header			mach_header_64
# define segment_command		segment_command_64
# undef  VM_REGION_BASIC_INFO_COUNT
# define VM_REGION_BASIC_INFO_COUNT	VM_REGION_BASIC_INFO_COUNT_64
# undef  VM_REGION_BASIC_INFO
# define VM_REGION_BASIC_INFO		VM_REGION_BASIC_INFO_64
# undef  LC_SEGMENT
# define LC_SEGMENT			LC_SEGMENT_64
# define vm_region			vm_region_64
# define section			section_64
# undef MH_MAGIC
# define MH_MAGIC			MH_MAGIC_64
#endif /* _LP64 */

#ifndef VERBOSE
# define VERBOSE 1
#endif /* !VERBOSE */

/* Size of buffer used to copy data from the input file to the output
   file in function unexec_copy.  */
#define UNEXEC_COPY_BUFSZ 1024UL

/* Regions with memory addresses above this value are assumed to be
   mapped to dynamically loaded libraries and will not be dumped.  */
#if 0
# define VM_DATA_TOP (20 * 1024 * 1024) /* i.e. 20971520 */
#else
/* `size -m -x -l` can be used to find the proper value for this. */
/* should actually be: 0x10059e000, i.e. 4300857344 in decimal */
# define VM_DATA_TOP (8192UL * 7UL * 179UL * 419UL)
/* thanks, WolframAlpha, for the help with the factorization! */
#endif /* 0 */
/* (we should really calculate this value dynamically; it keeps twitching
 *  around with the slightest of changes...) */


/* Type of an element on the list of regions to be dumped.  */
struct region_t {
  vm_address_t address;
  vm_size_t size;
  vm_prot_t protection;
  vm_prot_t max_protection;

  struct region_t *next;
};

/* Head and tail of the list of regions to be dumped: */
static struct region_t *region_list_head = (struct region_t *)0;
static struct region_t *region_list_tail = (struct region_t *)0;

/* Pointer to array of load commands: */
static struct load_command **lca;

/* Number of load commands: */
static int nlc;

/* Similarly: */
static int nlc_written = 0;

/* The highest VM address of segments loaded by the input file.
   Regions with addresses beyond this are assumed to be allocated
   dynamically and thus require dumping.  */
static vm_address_t infile_lc_highest_addr = (vm_address_t)0U;

/* The lowest file offset used by the all sections in the __TEXT
   segments.  This leaves room at the beginning of the file to store
   the Mach-O header.  Check this value against header size to ensure
   the added load commands for the new __DATA segments did not
   overwrite any of the sections in the __TEXT segment.  */
static unsigned long text_seg_lowest_offset = 0x10000000;

/* Mach header: */
static struct mach_header mh;

/* Offset at which the next load command should be written: */
static unsigned long curr_header_offset = sizeof(struct mach_header);

/* Offset at which the next segment should be written: */
static unsigned long curr_file_offset = 0UL;

static unsigned long pagesize;
#define ROUNDUP_TO_PAGE_BOUNDARY(x) (((x) + pagesize - 1) & ~(pagesize - 1))

static int infd, outfd;

static int in_dumped_exec = 0;

static malloc_zone_t *emacs_zone;

/* A macro for debugging the emacs_zone: */
#if 1
# define check_emacs_zone() emacs_zone->introspect->check(emacs_zone)
#else
# define check_emacs_zone() /* (nothing) */
#endif /* 1 */

/* file offset of input file's data segment: */
static off_t data_segment_old_fileoff = 0L;

static struct segment_command *data_segment_scp;

/* some prototypes from this file: */
void unexec_init_emacs_zone(void);
void *unexec_malloc(size_t size);
void *unexec_realloc(void *old_ptr, size_t new_size);
void unexec_free(void *ptr);

/*****************************/
/* Now the actual functions: */
/*****************************/

/* Read N bytes from infd into memory starting at address DEST.
   Return true if successful, false otherwise.  */
static int unexec_read(void *dest, size_t n)
{
  return (n == (size_t)read(infd, dest, n));
}

/* Write COUNT bytes from memory starting at address SRC to outfd
   starting at offset DEST.  Return true if successful, false
   otherwise.  */
static int unexec_write(off_t dest, const void *src, size_t count)
{
  if (lseek(outfd, dest, SEEK_SET) != dest)
    return 0;

  return (write(outfd, src, count) == (ssize_t)count);
}

/* Write COUNT bytes of zeros to outfd starting at offset DEST.
   Return true if successful, false otherwise.  */
static int unexec_write_zero(off_t dest, size_t count)
{
  char buf[UNEXEC_COPY_BUFSZ];
  ssize_t bytes;

  memset(buf, 0, (size_t)UNEXEC_COPY_BUFSZ);
  if (lseek(outfd, dest, SEEK_SET) != dest)
    return 0;

  while (count > 0UL)
    {
      bytes = ((count > UNEXEC_COPY_BUFSZ)
               ? (ssize_t)UNEXEC_COPY_BUFSZ : (ssize_t)count);
      if (write(outfd, buf, (size_t)bytes) != bytes)
	return 0;
      count -= (size_t)bytes;
    }

  return 1;
}

/* Copy COUNT bytes from starting offset SRC in infd to starting
   offset DEST in outfd.  Return true if successful, false
   otherwise.  */
static int unexec_copy(off_t dest, off_t src, ssize_t count)
{
  ssize_t bytes_read;
  ssize_t bytes_to_read;

  char buf[UNEXEC_COPY_BUFSZ];

  if (lseek(infd, src, SEEK_SET) != src)
    return 0;

  if (lseek(outfd, dest, SEEK_SET) != dest)
    return 0;

  while (count > 0L)
    {
      bytes_to_read = ((count > (ssize_t)UNEXEC_COPY_BUFSZ)
                       ? (ssize_t)UNEXEC_COPY_BUFSZ : count);
      bytes_read = read(infd, buf, (size_t)bytes_to_read);
      if (bytes_read <= 0)
	return 0;
      if (write(outfd, buf, (size_t)bytes_read) != bytes_read)
	return 0;
      count -= bytes_read;
    }

  return 1;
}

/* in case gnulib re-defined these on us: */
#ifdef BUILDING_FROM_XCODE
# ifdef strstr
#  undef strstr
# endif /* strstr */
# ifdef strerror
#  undef strerror
# endif /* strerror */
#endif /* BUILDING_FROM_XCODE */

/* Debugging and informational messages routines: */
#ifndef _GL_ATTRIBUTE_FORMAT
# if (defined(__GNUC__) && defined(__GNUC_MINOR__)) && \
     ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >= 7)))
#  define _GL_ATTRIBUTE_FORMAT(spec) __attribute__((__format__ spec))
# else
#  define _GL_ATTRIBUTE_FORMAT(spec) /* empty */
# endif /* gcc 2.7+ */
#endif /* !_GL_ATTRIBUTE_FORMAT */

#ifndef _GL_ATTRIBUTE_FORMAT_PRINTF
/* _GL_ATTRIBUTE_FORMAT_PRINTF
 * indicates to GCC that the function takes a format string and arguments,
 * where the format string directives are the ones standardized by ISO C99
 * and POSIX.  */
# if (defined(__GNUC__) && defined(__GNUC_MINOR__)) && \
     ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)))
#  define _GL_ATTRIBUTE_FORMAT_PRINTF(formatstring_parameter, first_argument) \
    _GL_ATTRIBUTE_FORMAT((__gnu_printf__, formatstring_parameter, first_argument))
# else
#  define _GL_ATTRIBUTE_FORMAT_PRINTF(formatstring_parameter, first_argument) \
    _GL_ATTRIBUTE_FORMAT((__printf__, formatstring_parameter, first_argument))
# endif /* gcc 4.4+ */
#endif /* !_GL_ATTRIBUTE_FORMAT_PRINTF */

static _Noreturn void _GL_ATTRIBUTE_FORMAT_PRINTF(1, 2)
unexec_error(const char *format, ...)
{
  va_list ap;
  int success = 0;

  va_start(ap, format);
  /* FIXME: the __FILE__ and __LINE__ should be of the place from where
   * this gets called; not this location itself: */
  fprintf(stderr, "%s, unexec line %d: ", __FILE__, __LINE__);
  success = vfprintf(stderr, format, ap);
  if (success != 0) {
#if defined(VERBOSE) && VERBOSE
    fprintf(stderr, " (vfprintf returned %d)", success);
#else
    fprintf(stderr, " ");
#endif /* VERBOSE */
  }
#if defined(VERBOSE) && VERBOSE
  if (errno > 0) {
    fprintf(stderr, " (errno is %d; i.e. \"%s\")", errno, strerror(errno));
  }
#endif /* VERBOSE */
  fprintf(stderr, "\n");
  va_end(ap);
  exit(1);
}

static void
print_prot(vm_prot_t prot)
{
  if (prot == VM_PROT_NONE)
    printf("none");
  else
    {
      putchar((prot & VM_PROT_READ) ? 'r' : ' ');
      putchar((prot & VM_PROT_WRITE) ? 'w' : ' ');
      putchar((prot & VM_PROT_EXECUTE) ? 'x' : ' ');
      putchar(' ');
    }
}

static void
print_region(vm_address_t address, vm_size_t size, vm_prot_t prot,
	     vm_prot_t max_prot)
{
  printf("%#10lx %#8lx ", (unsigned long)address, (unsigned long)size);
  print_prot(prot);
  putchar(' ');
  print_prot(max_prot);
  putchar('\n');
}

static void
print_region_list(void)
{
  struct region_t *r;
  int regions_printed = 0;

  printf("   address     size prot maxp\n");

  assert(region_list_head != NULL);

  for (r = region_list_head; r; r = r->next) {
    print_region(r->address, r->size, r->protection, r->max_protection);
    regions_printed++;
  }

#if (defined(VERBOSE) && VERBOSE) || defined(lint)
  if (regions_printed == 0) {
    fprintf(stderr, "Warning: failed to print any regions!\n");
  }
#endif /* VERBOSE || lint */
}

static void
print_regions(void)
{
  task_t target_task = mach_task_self();
  vm_address_t address = (vm_address_t)0;
  vm_size_t size;
  struct vm_region_basic_info info;
  mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT;
  mach_port_t object_name;
  int regions_printed = 0;

  printf("   address     size prot maxp\n");

  while ((vm_region(target_task, &address, &size, VM_REGION_BASIC_INFO,
                    (vm_region_info_t)&info, &info_count, &object_name)
          == KERN_SUCCESS) && (info_count == VM_REGION_BASIC_INFO_COUNT))
    {
      print_region(address, size, info.protection, info.max_protection);

      if (object_name != MACH_PORT_NULL)
	mach_port_deallocate(target_task, object_name);

      address += size;
      regions_printed++;
    }

#if (defined(VERBOSE) && VERBOSE) || defined(lint)
  if (regions_printed == 0) {
    fprintf(stderr, "Warning: failed to print any regions!\n");
  }
#endif /* VERBOSE || lint */
}

/* Build the list of regions that need to be dumped.  Regions with
   addresses above VM_DATA_TOP are omitted.  Adjacent regions with
   identical protection are merged.  Note that non-writable regions
   cannot be omitted because they some regions created at run time are
   read-only.  */
static void
build_region_list(void)
{
  task_t target_task = mach_task_self();
  vm_address_t address = (vm_address_t)0;
  vm_size_t size;
  struct vm_region_basic_info info;
  mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT;
  mach_port_t object_name;
  struct region_t *r;
  int regions_printed = 0;

#if defined(VERBOSE) && VERBOSE
  printf("--- List of All Regions ---\n");
  printf("   address     size prot maxp\n");
#endif /* VERBOSE */

  while ((vm_region(target_task, &address, &size, VM_REGION_BASIC_INFO,
                    (vm_region_info_t)&info, &info_count, &object_name)
          == KERN_SUCCESS) && (info_count == VM_REGION_BASIC_INFO_COUNT))
    {
      /* Done when we reach addresses of shared libraries, which are
       * loaded in high memory: */
      if (address >= VM_DATA_TOP) {
#if defined(VERBOSE) && VERBOSE
        printf("0x%lx is above 0x%lx; we must %s be into the shared libraries.\n",
               (unsigned long)address, VM_DATA_TOP, ((regions_printed <= 1)
                                                     ? "already" : "now"));
#endif /* VERBOSE */
	break;
      }

#if defined(VERBOSE) && VERBOSE
      print_region(address, size, info.protection, info.max_protection);
#endif /* VERBOSE */

      /* If a region immediately follows the previous one (the one
	 most recently added to the list) and has identical
	 protection, merge it with the latter.  Otherwise create a
	 new list element for it.  */
      if (region_list_tail
	  && (info.protection == region_list_tail->protection)
	  && (info.max_protection == region_list_tail->max_protection)
	  && region_list_tail->address + region_list_tail->size == address)
	{
	  region_list_tail->size += size;
	}
      else
	{
#ifdef __cplusplus
	  r = (struct region_t *)malloc(sizeof(*r));
#else
          r = malloc(sizeof(*r));
#endif /* __cplusplus */

	  if (!r)
	    unexec_error("cannot allocate region structure");

	  r->address = address;
	  r->size = size;
	  r->protection = info.protection;
	  r->max_protection = info.max_protection;

	  r->next = 0;
	  if (region_list_head == 0)
	    {
	      region_list_head = r;
	      region_list_tail = r;
	    }
	  else
	    {
	      if (region_list_tail != NULL) {
	        region_list_tail->next = r;
	      }
	      region_list_tail = r;
	    }

	  /* Deallocate (unused) object name returned by
	     vm_region.  */
	  if (object_name != MACH_PORT_NULL)
	    mach_port_deallocate(target_task, object_name);
	}

      address += size;
      regions_printed++;
    }

#if (defined(VERBOSE) && VERBOSE) || defined(lint)
  if (regions_printed == 0) {
    fprintf(stderr, "Warning: failed to print any regions!\n");
  }
#endif /* VERBOSE || lint */

  printf("--- List of Regions to be Dumped ---\n");
  print_region_list();
}


#define MAX_UNEXEC_REGIONS 400

static int num_unexec_regions;
typedef struct {
  vm_range_t range;
  vm_size_t filesize;
} unexec_region_info;
static unexec_region_info unexec_regions[MAX_UNEXEC_REGIONS];

static void
unexec_regions_recorder(task_t task, void *rr, unsigned int type,
                        vm_range_t *ranges, unsigned int num)
{
#if (defined(__APPLE__) && defined(__APPLE_CC__) && (__APPLE_CC__ > 1)) \
     && defined(lint)
# pragma unused (task, rr, type)
#endif /* (__APPLE__ && (__APPLE_CC__ > 1)) && lint */
  vm_address_t p;
  vm_size_t filesize;

  while ((num > 0U) && (num_unexec_regions < MAX_UNEXEC_REGIONS))
    {
      /* Subtract the size of trailing null bytes from filesize.  It
	 can be smaller than vmsize in segment commands.  In such a
	 case, trailing bytes are initialized with zeros.  */
      for (p = (ranges->address + ranges->size); p > ranges->address; p--)
      	if (*(((char *)p)-1))
      	  break;
      filesize = (p - ranges->address);

      unexec_regions[num_unexec_regions].filesize = filesize;
      unexec_regions[num_unexec_regions++].range = *ranges;
      printf("%#10lx (sz: %#8lx/%#8lx) (%u to go in this loop)\n",
             (unsigned long)(ranges->address), (unsigned long)filesize,
             (unsigned long)(ranges->size), (num - 1U));
      ranges++; num--;
    }
}

static kern_return_t
unexec_reader(task_t task, vm_address_t address, vm_size_t sz, void **ptr)
{
#if (defined(__APPLE__) && defined(__APPLE_CC__) && (__APPLE_CC__ > 1)) \
    && defined(lint)
# pragma unused (task, sz)
#endif /* (__APPLE__ && (__APPLE_CC__ > 1)) && lint */
  *ptr = (void *)address;
  return KERN_SUCCESS;
}

static void
find_emacs_zone_regions(void)
{
  num_unexec_regions = 0;

  check_emacs_zone();

  emacs_zone->introspect->enumerator(mach_task_self(), 0,
				     (MALLOC_PTR_REGION_RANGE_TYPE
                                      | MALLOC_ADMIN_REGION_RANGE_TYPE),
				     (vm_address_t)emacs_zone,
				     unexec_reader,
				     unexec_regions_recorder);

  if (num_unexec_regions == MAX_UNEXEC_REGIONS)
    unexec_error("find_emacs_zone_regions: too many regions");
}

static int
unexec_regions_sort_compare(const void *a, const void *b)
{
  vm_address_t aa = ((unexec_region_info *)a)->range.address;
  vm_address_t bb = ((unexec_region_info *)b)->range.address;

  if (aa < bb)
    return -1;
  else if (aa > bb)
    return 1;
  else
    return 0;
}

static void unexec_regions_merge(void)
{
  int i, n;
  vm_address_t begin = 0, end;
  unexec_region_info r;
#ifdef ALLOW_UNUSED_VARIABLES
  long total = 0L;
#endif /* ALLOW_UNUSED_VARIABLES */
  void *zeropage = calloc((size_t)1UL, pagesize);
  vm_size_t padsize;

  qsort(unexec_regions, (size_t)num_unexec_regions,
        sizeof(unexec_regions[0]), &unexec_regions_sort_compare);
  n = 0;
  r = unexec_regions[0];
  padsize = (r.range.address & (pagesize - 1L));
  if (padsize) {
    begin = r.range.address;
    r.range.address -= padsize;
    r.range.size += padsize;
    r.filesize += padsize;
  }
  for (i = 1; i < num_unexec_regions; i++) {
    if (((r.range.address + r.range.size) == unexec_regions[i].range.address)
        && ((r.range.size - r.filesize) < (2 * pagesize))) {
      r.filesize = (r.range.size + unexec_regions[i].filesize);
      r.range.size += unexec_regions[i].range.size;
    } else { /* All segments must be a multiple of pagesize: */
      end = (r.range.address + r.range.size);
      if (end & (pagesize - 1L)) {
        end = ROUNDUP_TO_PAGE_BOUNDARY(end);
        printf("Page (%#8lx) aligning region @%#8lx size from %#8lx to %#8lx\n",
               (unsigned long)pagesize, (unsigned long)r.range.address,
               (unsigned long)r.range.size,
               (unsigned long)(end - r.range.address));
        r.range.size = (end - r.range.address);
        r.filesize = r.range.size;
        if (end == unexec_regions[i].range.address) {
          r.filesize += unexec_regions[i].filesize;
          r.range.size += unexec_regions[i].range.size;
          continue;
        }
      }
      /* Truncate zerod pages: */
      while (r.filesize > 0) {
        vm_address_t p = (r.range.address + r.filesize - pagesize);
        if (memcmp((const void *)p, zeropage, pagesize) == 0) {
          r.filesize -= pagesize;
        } else {
          break;
        }
      }
      if (r.filesize != r.range.size) {
        printf("Region %d: removed %lx zerod bytes from filesize\n", i,
               (unsigned long)(r.range.size - r.filesize));
      }
      unexec_regions[n++] = r;
      r = unexec_regions[i];
      padsize = (r.range.address & (pagesize - 1UL));
      if (padsize) { /* Align beginning of unmerged region */
        if ((unexec_regions[n - 1].range.address
             + unexec_regions[n - 1].range.size) == r.range.address) {
          unexec_regions[n - 1].range.size -= padsize;
        }
        begin = r.range.address;
        r.range.address -= padsize;
        r.range.size += padsize;
        r.filesize += padsize;
      }
    }
  }
  end = (r.range.address + r.range.size);
  if (end & (pagesize - 1L)) {
    end = ROUNDUP_TO_PAGE_BOUNDARY(end);
    printf("Page (%#8lx) aligning region @%#8lx size from %#8lx to %#8lx\n",
           pagesize, (unsigned long)r.range.address,
           (unsigned long)r.range.size,
           (unsigned long)(end - r.range.address));
    r.range.size = end - r.range.address;
    r.filesize = r.range.size;
  }
  /* Truncate zerod pages: */
  while (r.filesize > 0) {
    vm_address_t p = (r.range.address + r.filesize - pagesize);
    if (memcmp((const void *)p, zeropage, pagesize) == 0) {
      r.filesize -= pagesize;
    } else {
      break;
    }
  }
  free(zeropage);
  if (r.filesize != r.range.size) {
    printf("Removed %lx zerod bytes from filesize\n",
           (unsigned long)(r.range.size - r.filesize));
  }
  unexec_regions[n++] = r;
  num_unexec_regions = n;

#ifdef lint
  if (begin > end) {
    /* we return at the end anyways by falling off the end of the function;
     * this condition just uses the variable 'begin' to keep the compiler
     * happy: */
    return;
  }
#endif /* lint */
}


/* More informational messages routines: */
static void print_load_command_name(long lc)
{
  /* FIXME: have the number of trailing spaces vary based on the length of
   * whatever the longest LC name is, instead of hard-coding them: */
  switch (lc)
    {
    case LC_SEGMENT:
#ifndef _LP64
      printf("LC_SEGMENT (0x%08x)       ",
             (unsigned int)LC_SEGMENT);
#else
      printf("LC_SEGMENT_64 (0x%08x)    ",
             (unsigned int)LC_SEGMENT_64);
#endif /* !_LP64 */
      break;
    case LC_LOAD_DYLINKER:
      printf("LC_LOAD_DYLINKER (0x%08x) ",
             (unsigned int)LC_LOAD_DYLINKER);
      break;
    case LC_LOAD_DYLIB:
      printf("LC_LOAD_DYLIB (0x%08x)    ",
             (unsigned int)LC_LOAD_DYLIB);
      break;
    case LC_ID_DYLIB:
      printf("LC_ID_DYLIB (0x%08x)            ",
             (unsigned int)LC_ID_DYLIB);
      break;
    case LC_SYMTAB:
      printf("LC_SYMTAB (0x%08x)        ",
             (unsigned int)LC_SYMTAB);
      break;
    case LC_SYMSEG:
      printf("LC_SYMSEG (0x%08x)              ",
             (unsigned int)LC_SYMSEG);
      break;
    case LC_DYSYMTAB:
      printf("LC_DYSYMTAB (0x%08x)      ",
             (unsigned int)LC_DYSYMTAB);
      break;
    case LC_UNIXTHREAD:
      printf("LC_UNIXTHREAD (0x%08x)    ",
             (unsigned int)LC_UNIXTHREAD);
      break;
    case LC_PREBOUND_DYLIB:
      printf("LC_PREBOUND_DYLIB (0x%08x)",
             (unsigned int)LC_PREBOUND_DYLIB);
      break;
    case LC_ROUTINES:
      printf("LC_ROUTINES (0x%08x)            ",
             (unsigned int)LC_ROUTINES);
      break;
    case LC_SUB_FRAMEWORK:
      printf("LC_SUBFRAMEWORK (0x%08x)        ",
             (unsigned int)LC_SUB_FRAMEWORK);
      break;
    case LC_SUB_UMBRELLA:
      printf("LC_SUB_UMBRELLA (0x%08x)        ",
             (unsigned int)LC_SUB_UMBRELLA);
      break;
    case LC_SUB_CLIENT:
      printf("LC_SUB_CLIENT (0x%08x)          ",
             (unsigned int)LC_SUB_CLIENT);
      break;
    case LC_SUB_LIBRARY:
      printf("LC_SUB_LIBRARY (0x%08x)         ",
             (unsigned int)LC_SUB_LIBRARY);
      break;
    case LC_TWOLEVEL_HINTS:
      printf("LC_TWOLEVEL_HINTS (0x%08x)",
             (unsigned int)LC_TWOLEVEL_HINTS);
      break;
    case LC_PREBIND_CKSUM:
      printf("LC_PREBIND_CKSUM (0x%08x)       ",
             (unsigned int)LC_PREBIND_CKSUM);
      break;
    case LC_LOAD_WEAK_DYLIB:
      printf("LC_LOAD_WEAK_DYLIB (0x%08x)     ",
             (unsigned int)LC_LOAD_WEAK_DYLIB);
      break;
#if !defined(_LP64) && (LC_SEGMENT != LC_SEGMENT_64)
    case LC_SEGMENT_64:
      printf("LC_SEGMENT_64 (0x%08x)          ",
             (unsigned int)LC_SEGMENT_64);
      break;
#endif /* !_LP64 && (LC_SEGMENT != LC_SEGMENT_64) */
    case LC_ROUTINES_64:
      printf("LC_ROUTINES_64 (0x%08x)         ",
             (unsigned int)LC_ROUTINES_64);
      break;
#ifdef LC_UUID
    case LC_UUID:
      printf("LC_UUID (0x%08x)          ",
             (unsigned int)LC_UUID);
      break;
#endif /* LC_UUID */
    case LC_RPATH:
      printf("LC_RPATH (0x%08x)               ",
             (unsigned int)LC_RPATH);
      break;
    case LC_CODE_SIGNATURE:
      printf("LC_CODE_SIGNATURE (0x%08x)      ",
             (unsigned int)LC_CODE_SIGNATURE);
      break;
    case LC_SEGMENT_SPLIT_INFO:
      printf("LC_SEGMENT_SPLIT_INFO (0x%08x)  ",
             (unsigned int)LC_SEGMENT_SPLIT_INFO);
      break;
    case LC_REEXPORT_DYLIB:
      printf("LC_REEXPORT_DYLIB (0x%08x)      ",
             (unsigned int)LC_REEXPORT_DYLIB);
      break;
    case LC_LAZY_LOAD_DYLIB:
      printf("LC_LAZY_LOAD_DYLIB (0x%08x)     ",
             (unsigned int)LC_LAZY_LOAD_DYLIB);
      break;
    case LC_ENCRYPTION_INFO:
      printf("LC_ENCRYPTION_INFO (0x%08x)     ",
             (unsigned int)LC_ENCRYPTION_INFO);
      break;
#ifdef LC_DYLD_INFO
    case LC_DYLD_INFO:
      printf("LC_DYLD_INFO (0x%08x)     ",
             (unsigned int)LC_DYLD_INFO);
      break;
    case LC_DYLD_INFO_ONLY:
      printf("LC_DYLD_INFO_ONLY (0x%08x)",
             (unsigned int)LC_DYLD_INFO_ONLY);
      break;
#endif /* LC_DYLD_INFO */
#ifdef LC_LOAD_UPWARD_DYLIB
    case LC_LOAD_UPWARD_DYLIB:
      printf("LC_LOAD_UPWARD_DYLIB (0x%08x)   ",
             (unsigned int)LC_LOAD_UPWARD_DYLIB);
      break;
#endif /* LC_LOAD_UPWARD_DYLIB */
#ifdef LC_VERSION_MIN_MACOSX
    case LC_VERSION_MIN_MACOSX:
      printf("LC_VERSION_MIN_MACOSX (0x%08x)",
             (unsigned int)LC_VERSION_MIN_MACOSX);
      break;
#endif /* LC_VERSION_MIN_MACOSX */
#ifdef LC_VERSION_MIN_IPHONEOS
    case LC_VERSION_MIN_IPHONEOS:
      printf("LC_VERSION_MIN_IPHONEOS (0x%08x)",
             (unsigned int)LC_VERSION_MIN_IPHONEOS);
      break;
#endif /* LC_VERSION_MIN_IPHONEOS */
#ifdef LC_FUNCTION_STARTS
    case LC_FUNCTION_STARTS:
      printf("LC_FUNCTION_STARTS (0x%08x)",
             (unsigned int)LC_FUNCTION_STARTS);
      break;
#endif /* LC_FUNCTION_STARTS */
#ifdef LC_DYLD_ENVIRONMENT
    case LC_DYLD_ENVIRONMENT:
      printf("LC_DYLD_ENVIRONMENT (0x%08x)    ",
             (unsigned int)LC_DYLD_ENVIRONMENT);
      break;
#endif /* LC_DYLD_ENVIRONMENT */
#ifdef LC_MAIN
    case LC_MAIN:
      printf("LC_MAIN (0x%08x)          ",
             (unsigned int)LC_MAIN);
      break;
#endif /* LC_MAIN */
#ifdef LC_DATA_IN_CODE
    case LC_DATA_IN_CODE:
      printf("LC_DATA_IN_CODE (0x%08x)  ",
             (unsigned int)LC_DATA_IN_CODE);
      break;
#endif /* LC_DATA_IN_CODE */
#ifdef LC_SOURCE_VERSION
    case LC_SOURCE_VERSION:
      printf("LC_SOURCE_VERSION (0x%08x)",
             (unsigned int)LC_SOURCE_VERSION);
      break;
#endif /* LC_SOURCE_VERSION */
#ifdef LC_DYLIB_CODE_SIGN_DRS
    case LC_DYLIB_CODE_SIGN_DRS:
      printf("LC_DYLIB_CODE_SIGN_DRS (0x%08x)",
             (unsigned int)LC_DYLIB_CODE_SIGN_DRS);
      break;
#endif /* LC_DYLIB_CODE_SIGN_DRS */
    default:
      printf("unknown(0x%08x)", (unsigned int)lc);
      break;
    }
}

static void
print_load_command(struct load_command *lc)
{
  print_load_command_name((long)lc->cmd);

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  /* FIXME: dirty hack; instead of hardcoding this, we should be adjusting
   * it dynamically: */
#ifdef LC_VERSION_MIN_MACOSX
  if (lc->cmd == LC_VERSION_MIN_MACOSX)
    {
      printf("%4u", lc->cmdsize);
    }
# ifdef LC_FUNCTION_STARTS
  else if (lc->cmd == LC_FUNCTION_STARTS)
    {
      printf("%7u", lc->cmdsize);
    }
# endif /* LC_FUNCTION_STARTS */
  else
#endif /* LC_VERSION_MIN_MACOSX */
    {
      printf("%8u", lc->cmdsize);
    }

  if ((lc->cmd == LC_SEGMENT) || (lc->cmd == LC_SEGMENT_64))
    {
      struct segment_command *scp;
      struct section *sectp;
      uint32_t j;

      scp = (struct segment_command *)lc;
      printf(" %-16.16s %#11lx %#11lx\n",
	     scp->segname, (unsigned long)(scp->vmaddr),
             (unsigned long)(scp->vmsize));

      sectp = (struct section *)(scp + 1);
      for (j = 0U; (j < scp->nsects) && (j < UINT_MAX); j++)
	{
	  printf("                           %-16.16s %#10lx %#8lx (flags: %#10lx)\n",
		 sectp->sectname, (unsigned long)(sectp->addr),
                 (unsigned long)(sectp->size),
                 (unsigned long)(sectp->flags));
	  sectp++;
	}
    }
  else
    printf("\n");
}


/* for better diagnostics with switch statements: */
enum mach_header_filetype_constants_e
{
  MH_OBJECT_e = MH_OBJECT,
  MH_EXECUTE_e = MH_EXECUTE,
  MH_FVMLIB_e = MH_FVMLIB,
  MH_CORE_e = MH_CORE,
  MH_PRELOAD_e = MH_PRELOAD,
  MH_DYLIB_e = MH_DYLIB,
  MH_DYLINKER_e = MH_DYLINKER,
  MH_BUNDLE_e = MH_BUNDLE,
  MH_DYLIB_STUB_e = MH_DYLIB_STUB,
  MH_DSYM_e = MH_DSYM
#ifdef MH_KEXT_BUNDLE
  , MH_KEXT_BUNDLE_e = MH_KEXT_BUNDLE
#endif /* MH_KEXT_BUNDLE */
};

/* Like strerror(), but for mach filetype flags: */
static const char *strmachfiletype(uint32_t inflags)
{
  enum mach_header_filetype_constants_e flags_e;
  flags_e = (enum mach_header_filetype_constants_e)inflags;
  switch (flags_e) {
    case MH_OBJECT_e:
      return "relocatable object file";
    case MH_EXECUTE_e:
      return "demand-paged executable file";
    case MH_FVMLIB_e:
      return "fixed-VM shared library file";
    case MH_CORE_e:
      return "core file";
    case MH_PRELOAD_e:
      return "preloaded executable file";
    case MH_DYLIB_e:
      return "dynamically-bound shared library";
    case MH_DYLINKER_e:
      return "dynamic link editor";
    case MH_BUNDLE_e:
      return "dynamically-bound bundle file";
    case MH_DYLIB_STUB_e:
      return "shared library stub for static linking only, no section contents";
    case MH_DSYM_e:
      return "companion debug symbols file with only debug sections";
#ifdef MH_KEXT_BUNDLE
    case MH_KEXT_BUNDLE_e:
      return "x86_64 kext";
#endif /* MH_KEXT_BUNDLE */
    default:
      return "unknown";
  }
}

/* Read header and load commands from input file.  Store the latter in
   the global array lca.  Store the total number of load commands in
   global variable nlc.  */
static void
read_load_commands(void)
{
  int i;
  const char *magic_typestring = "         ";
  const NXArchInfo *mh_cpuarchinfo;

  if (!unexec_read(&mh, sizeof(struct mach_header))) {
    unexec_error("cannot read mach-o header");
  } else {
    mh_cpuarchinfo = NXGetArchInfoFromCpuType(mh.cputype, mh.cpusubtype);
  }

  if (mh.magic != MH_MAGIC) {
    unexec_error("input file not in correct Mach-O format");
  } else if (mh.magic == 0xfeedface) {
    magic_typestring = " (32-bit)";
  } else if (mh.magic == 0xfeedfacf) {
    magic_typestring = " (64-bit)";
  }

  if (mh.filetype != MH_EXECUTE)
    unexec_error("input Mach-O file is not an executable object file");

#if defined(VERBOSE) && VERBOSE
  printf("--- Header Information ---\n");
  printf("Magic = 0x%08x%s\n", mh.magic, magic_typestring);
  printf("CPUType = %d (i.e. \"%s\")\n", mh.cputype,
         mh_cpuarchinfo->name);
  printf("CPUSubType = %d (more specifically, \"%s\")\n", mh.cpusubtype,
         mh_cpuarchinfo->description);
  printf("FileType = 0x%x (%s)\n", mh.filetype,
         strmachfiletype(mh.filetype));
  printf("NCmds = %u\n", mh.ncmds);
  printf("SizeOfCmds = %u\n", mh.sizeofcmds);
  printf("Flags = 0x%08x\n", mh.flags);
  /* FIXME: print a string for the meaning of the flags.  This is a little
   * more complicated than the filetype, since the flags can be OR-ed
   * together, and as such, would need to be disentangled... */
#endif /* VERBOSE */

  nlc = (int)mh.ncmds;
#ifdef __cplusplus
  lca = (struct load_command **)malloc(nlc * sizeof(*lca));
#else
  lca = malloc((size_t)nlc * sizeof(*lca));
#endif /* __cplusplus */

  for (i = 0; i < nlc; i++)
    {
      struct load_command lc;
      /* Load commands are variable-size: so read the command type and
	 size first and then read the rest.  */
      if (!unexec_read(&lc, sizeof(struct load_command)))
        unexec_error("cannot read load command");

#ifdef __LP64__
      assert((lc.cmdsize % 8) == 0);
#else
      assert((lc.cmdsize % 4) == 0);
#endif /* __LP64__ */

#ifdef __cplusplus
      lca[i] = (struct load_command *)malloc(lc.cmdsize);
#else
      lca[i] = malloc(max(1UL, (size_t)lc.cmdsize));
#endif /* __cplusplus */
      memcpy(lca[i], &lc, sizeof(struct load_command));
      if (!unexec_read((lca[i] + 1),
                       (lc.cmdsize - sizeof(struct load_command))))
        unexec_error("cannot read content of load command");
      if ((lc.cmd == LC_SEGMENT) || (lc.cmd == LC_SEGMENT_64))
	{
	  struct segment_command *scp = (struct segment_command *)lca[i];

	  if ((scp->vmaddr + scp->vmsize) > infile_lc_highest_addr)
	    infile_lc_highest_addr = (scp->vmaddr + scp->vmsize);

	  if (strncmp(scp->segname, SEG_TEXT, (size_t)16UL) == 0)
	    {
	      struct section *sectp = (struct section *)(scp + 1);
	      uint32_t j;

	      for (j = 0U; (j < scp->nsects) && (j < UINT_MAX); j++)
		if (sectp->offset < text_seg_lowest_offset)
		  text_seg_lowest_offset = sectp->offset;
	    }
	}
    }

  printf("Highest address of load commands in input file: %#9lx\n",
	 (unsigned long)infile_lc_highest_addr);

  printf("Lowest offset of all sections in __TEXT segment: %#10lx\n",
	 text_seg_lowest_offset);

  printf("--- List of Load Commands in Input File ---\n");
  printf(" # cmd           cmdnum           cmdsize segname              address        size\n");

  for (i = 0; i < nlc; i++)
    {
      printf("%2d ", i);
      print_load_command(lca[i]);
    }
}

/* Copy a LC_SEGMENT load command other than the __DATA segment from
   the input file to the output file, adjusting the file offset of the
   segment and the file offsets of sections contained in it.  */
static void
copy_segment(struct load_command *lc)
{
  struct segment_command *scp = (struct segment_command *)lc;
  unsigned long old_fileoff = scp->fileoff;
  struct section *sectp;
  uint32_t j;

  scp->fileoff = curr_file_offset;

  sectp = (struct section *)(scp + 1);
  for (j = 0U; (j < scp->nsects) && (j < UINT_MAX); j++)
    {
      sectp->offset += (uint32_t)(curr_file_offset - old_fileoff);
      sectp++;
    }

#if defined(VERBOSE) && (VERBOSE > 1)
  /* this looks ugly interwoven with the rest of the text: */
  printf("Writing ");
  print_load_command_name((long)lc->cmd);
  printf(" \t\tcommand (%2d)\n", ++nlc_written);
#else
  /* still need to increment the counter, even if not printing it: */
  ++nlc_written;
#endif /* VERBOSE > 1 */

  printf("Writing segment %-16.16s @ %#9lx (%#8lx/%#11lx @ %#11lx)\n",
	 scp->segname, (unsigned long)(scp->fileoff),
         (unsigned long)(scp->filesize), (unsigned long)(scp->vmsize),
         (unsigned long)(scp->vmaddr));

  if (!unexec_copy((off_t)scp->fileoff, (off_t)old_fileoff,
                   (ssize_t)scp->filesize))
    unexec_error("cannot copy segment from input to output file");
  curr_file_offset += ROUNDUP_TO_PAGE_BOUNDARY(scp->filesize);

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write load command to header");

  curr_header_offset += lc->cmdsize;
}

/* for better diagnostics with switch statements: */
enum secttype_flags_e
{
  S_REGULAR_e = S_REGULAR,
  S_ZEROFILL_e = S_ZEROFILL,
  S_CSTRING_LITERALS_e = S_CSTRING_LITERALS,
  S_4BYTE_LITERALS_e = S_4BYTE_LITERALS,
  S_8BYTE_LITERALS_e = S_8BYTE_LITERALS,
  S_LITERAL_POINTERS_e = S_LITERAL_POINTERS,
  S_NON_LAZY_SYMBOL_POINTERS_e = S_NON_LAZY_SYMBOL_POINTERS,
  S_LAZY_SYMBOL_POINTERS_e = S_LAZY_SYMBOL_POINTERS,
  S_SYMBOL_STUBS_e = S_SYMBOL_STUBS,
  S_MOD_INIT_FUNC_POINTERS_e = S_MOD_INIT_FUNC_POINTERS,
  S_MOD_TERM_FUNC_POINTERS_e = S_MOD_TERM_FUNC_POINTERS,
  S_COALESCED_e = S_COALESCED,
  S_GB_ZEROFILL_e = S_GB_ZEROFILL,
  S_INTERPOSING_e = S_INTERPOSING,
  S_16BYTE_LITERALS_e = S_16BYTE_LITERALS,
  S_DTRACE_DOF_e = S_DTRACE_DOF,
  S_LAZY_DYLIB_SYMBOL_POINTERS_e = S_LAZY_DYLIB_SYMBOL_POINTERS
#ifdef S_THREAD_LOCAL_REGULAR
  , S_THREAD_LOCAL_REGULAR_e = S_THREAD_LOCAL_REGULAR
#endif /* S_THREAD_LOCAL_REGULAR */
#ifdef S_THREAD_LOCAL_ZEROFILL
  , S_THREAD_LOCAL_ZEROFILL_e = S_THREAD_LOCAL_ZEROFILL
#endif /* S_THREAD_LOCAL_ZEROFILL */
#ifdef S_THREAD_LOCAL_VARIABLES 
  , S_THREAD_LOCAL_VARIABLES_e = S_THREAD_LOCAL_VARIABLES
#endif /* S_THREAD_LOCAL_VARIABLES */
#ifdef S_THREAD_LOCAL_VARIABLE_POINTERS
  , S_THREAD_LOCAL_VARIABLE_POINTERS_e = S_THREAD_LOCAL_VARIABLE_POINTERS
#endif /* S_THREAD_LOCAL_VARIABLE_POINTERS */
#ifdef S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
  , S_THREAD_LOCAL_INIT_FUNCTION_POINTERS_e = S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
#endif /* S_THREAD_LOCAL_INIT_FUNCTION_POINTERS */
};

/* Like strerror(), but for section type flags: */
static const char *strsecttype(int inflags)
{
  enum secttype_flags_e flags_e = (enum secttype_flags_e)inflags;
  switch (flags_e) {
    case S_REGULAR_e:
      return "regular";
    case S_ZEROFILL_e:
      return "zerofill";
    case S_CSTRING_LITERALS_e:
      return "literal C strings";
    case S_4BYTE_LITERALS_e:
      return "4 byte literals";
    case S_8BYTE_LITERALS_e:
      return "8 byte literals";
    case S_LITERAL_POINTERS_e:
      return "pointers to literals";
    case S_NON_LAZY_SYMBOL_POINTERS_e:
      return "non-lazy symbol pointers";
    case S_LAZY_SYMBOL_POINTERS_e:
      return "lazy symbol pointers";
    case S_SYMBOL_STUBS_e:
      return "symbol stubs";
    case S_MOD_INIT_FUNC_POINTERS_e:
      return "function pointers for initialization";
    case S_MOD_TERM_FUNC_POINTERS_e:
      return "function pointers for termination";
    case S_COALESCED_e:
      return "to be coalesced";
    case S_GB_ZEROFILL_e:
      return "zerofill that can be greater than 4 gigabytes";
    case S_INTERPOSING_e:
      return "pairs of function pointers for interposing";
    case S_16BYTE_LITERALS_e:
      return "16 byte literals";
    case S_DTRACE_DOF_e:
      return "DTrace Object Format";
    case S_LAZY_DYLIB_SYMBOL_POINTERS_e:
      return "lazy symbol pointers to lazily loaded dylibs";
#ifdef S_THREAD_LOCAL_REGULAR
    case S_THREAD_LOCAL_REGULAR_e:
      return "regular Thread-Local Variable values";
#endif /* S_THREAD_LOCAL_REGULAR */
#ifdef S_THREAD_LOCAL_ZEROFILL
    case S_THREAD_LOCAL_ZEROFILL_e:
      return "zerofill Thread-Local Variable values";
#endif /* S_THREAD_LOCAL_ZEROFILL */
#ifdef S_THREAD_LOCAL_VARIABLES
    case S_THREAD_LOCAL_VARIABLES_e:
      return "Thread-Local Variable descriptors";
#endif /* S_THREAD_LOCAL_VARIABLES */
#ifdef S_THREAD_LOCAL_VARIABLE_POINTERS
    case S_THREAD_LOCAL_VARIABLE_POINTERS_e:
      return "pointers to Thread-Local Variable descriptors";
#endif /* S_THREAD_LOCAL_VARIABLE_POINTERS */
#ifdef S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
    case S_THREAD_LOCAL_INIT_FUNCTION_POINTERS_e:
      return "functions to call to intialize Thread-Local Variable values";
#endif /* S_THREAD_LOCAL_INIT_FUNCTION_POINTERS */
    default:
      return "unknown";
  }
}

/* Copy a LC_SEGMENT load command for the __DATA segment in the input
   file to the output file.  We assume that only one such segment load
   command exists in the input file and it contains the sections
   __data, __bss, __common, __la_symbol_ptr, __nl_symbol_ptr, and
   __dyld.  The first three of these should be dumped from memory and
   the rest should be copied from the input file.  Note that the
   sections __bss and __common contain no data in the input file
   because their flag fields have the value S_ZEROFILL.  Dumping these
   from memory makes it necessary to adjust file offset fields in
   subsequently dumped load commands.  Then, create new __DATA segment
   load commands for regions on the region list other than the one
   corresponding to the __DATA segment in the input file.  */
static void
copy_data_segment(struct load_command *lc)
{
  struct segment_command *scp = (struct segment_command *)lc;
  struct section *sectp;
  uint32_t j;
  unsigned long header_offset, old_file_offset;
  long total;
  uint32_t total_size = 0U;

#if defined(VERBOSE) && (VERBOSE > 1)
  /* this looks ugly interwoven with the rest of the text: */
  printf("Writing ");
  print_load_command_name((long)lc->cmd);
  printf(" \t\tcommand (%2d)\n", ++nlc_written);
#else
  /* still need to increment the counter, even if not printing it: */
  ++nlc_written;
#endif /* VERBOSE > 1 */

  assert(scp->vmsize >= scp->filesize);
  assert(scp->vmsize >= scp->cmdsize);
  assert(scp->vmsize >= scp->nsects);
  assert(scp->vmsize >= (scp->cmdsize * scp->nsects));

#if defined(VERBOSE) && (VERBOSE > 1)
  printf("All fields of segment to be written: "
         "cmd: %u, cmdsize: %u, segname: %s, vmaddr: %llu, vmsize: %llu, "
         "fileoff: %llu, filesize: %llu, maxprot: %d, initprot: %d, "
         "nsects: %u, flags: %u.\n",
         scp->cmd, scp->cmdsize, scp->segname, scp->vmaddr, scp->vmsize,
         scp->fileoff, scp->filesize, scp->maxprot, scp->initprot,
         scp->nsects, scp->flags);
#endif /* VERBOSE > 1 */

  /* The new filesize of the segment is set to its vmsize because data
     blocks for segments must start at region boundaries.  Note that
     this may leave unused locations at the end of the segment data
     block because the total of the sizes of all sections in the
     segment is generally smaller than vmsize.  */
  scp->filesize = scp->vmsize;

  printf("Writing segment %-16.16s @ %#9lx (%#8lx/%#11lx @ %#11lx)\n",
	 scp->segname, curr_file_offset, (unsigned long)(scp->filesize),
	 (unsigned long)(scp->vmsize), (unsigned long)(scp->vmaddr));

  /* Offsets in the output file for writing the next section structure
     and segment data block, respectively.  */
  header_offset = (curr_header_offset + sizeof(struct segment_command));

  sectp = (struct section *)(scp + 1);
  for (j = 0U; (j < scp->nsects) && (j < UINT_MAX); j++)
    {
      unsigned char sect_type;
      old_file_offset = sectp->offset;
      sectp->offset = (uint32_t)((sectp->addr - scp->vmaddr)
                                 + curr_file_offset);
      /* The __data section is dumped from memory.  The __bss and
	 __common sections are also dumped from memory but their flag
	 fields require changing (from S_ZEROFILL to S_REGULAR).  The
	 other three kinds of sections are just copied from the input
	 file.  */

      sect_type = (sectp->flags & SECTION_TYPE);

      switch (sect_type) {
      case S_LAZY_SYMBOL_POINTERS:
      case S_NON_LAZY_SYMBOL_POINTERS:
      case S_CSTRING_LITERALS:
	  if (!unexec_copy((off_t)sectp->offset, (off_t)old_file_offset,
                           (ssize_t)sectp->size))
	    unexec_error("cannot copy section %s", sectp->sectname);
	  if (!unexec_write((off_t)header_offset, sectp,
                            sizeof(struct section)))
	    unexec_error("cannot write section %s's header",
                         sectp->sectname);
	  break;

      case S_REGULAR:
	if ((strncmp(sectp->sectname, "__const", 16UL) == 0)
            || (strncmp(sectp->sectname, "__program_vars", 16UL) == 0)) {
          if (!unexec_copy((off_t)sectp->offset, (off_t)old_file_offset,
                           (ssize_t)sectp->size))
            unexec_error("cannot copy section %s", sectp->sectname);
	} else {
          if (!unexec_write((off_t)sectp->offset, (void *)sectp->addr,
                            sectp->size))
            unexec_error("cannot write section %s", sectp->sectname);
	}
	if (!unexec_write((off_t)header_offset, sectp,
                          sizeof(struct section)))
            unexec_error("cannot write section %s's header",
                         sectp->sectname);
	break;

      case S_ZEROFILL:
          if (!((strncmp(sectp->sectname, "__bss", 16UL) == 0)
                || (strncmp(sectp->sectname, "__common", 16UL) == 0)
                || (strstr(sectp->sectname, "__bss") != NULL)
                || (strstr(sectp->sectname, "__pu_bss") != NULL))) {
            /* ???: are the __pu_bss sections okay, or not? */
            fprintf(stderr,
                    "Warning: only expected __bss and __common sections "
                    "to be zerofilled, but this section is called %s.\n",
                    sectp->sectname);
          }
#if defined(VERBOSE) && (VERBOSE > 1)
          printf("Flags are 0x%01x, jumping to zerofilling part...\n",
                 (unsigned int)S_ZEROFILL);
#endif /* VERBOSE > 1 */
          goto zerofill_entry_point;
      default:
          if ((strncmp(sectp->sectname, SECT_DATA, 16UL) == 0)
              || (strncmp(sectp->sectname, SECT_COMMON, 16UL) == 0)
              || (strncmp(sectp->sectname, SECT_BSS, 16UL) == 0)
              || ((strncmp(sectp->sectname, "__la_symbol_ptr", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__nl_symbol_ptr", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__got", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__la_sym_ptr2", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__dyld", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__const", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__cfstring", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__gcc_except_tab", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__program_vars", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__mod_init_func", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__mod_term_func", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__static_data", 16UL) == 0)
                  || (strncmp(sectp->sectname, "__objc_", 7UL) == 0)))
            {
                break;
            }
          else
            {
                goto failure_spot;
            }
      }

      if (strncmp(sectp->sectname, SECT_DATA, 16UL) == 0)
	{
	  extern char my_edata[];
	  unsigned long my_size;

	  /* The __data section is basically dumped from memory.  But
	     initialized data in statically linked libraries are
	     copied from the input file.  In particular,
	     add_image_hook.names and add_image_hook.pointers stored
	     by libarclite_macosx.a, are restored so that they will be
	     reinitialized when the dumped binary is executed.  */
	  my_size = ((unsigned long)my_edata - sectp->addr);
	  if (!((sectp->addr <= (unsigned long)my_edata)
		&& (my_size <= sectp->size)))
	    unexec_error("my_edata is not in section %s", SECT_DATA);
	  if (!unexec_write((off_t)sectp->offset, (void *)sectp->addr,
                            my_size))
	    unexec_error("cannot write section %s", SECT_DATA);
	  if (!unexec_copy((off_t)(sectp->offset + my_size),
                           (off_t)(old_file_offset + my_size),
			   (ssize_t)(sectp->size - my_size)))
	    unexec_error("cannot copy section %s", SECT_DATA);
	  if (!unexec_write((off_t)header_offset, sectp,
                            sizeof(struct section)))
	    unexec_error("cannot write section %s's header", SECT_DATA);
	}
      else if (strncmp(sectp->sectname, SECT_COMMON, 16UL) == 0)
	{
	  sectp->flags = S_REGULAR;
	  if (!unexec_write((off_t)sectp->offset, (void *)sectp->addr,
                            sectp->size))
	    unexec_error("cannot write section %.16s", sectp->sectname);
	  if (!unexec_write((off_t)header_offset, sectp,
                            sizeof(struct section)))
	    unexec_error("cannot write section %.16s's header",
                         sectp->sectname);
	}
      else if (strncmp(sectp->sectname, SECT_BSS, 16UL) == 0)
	{
	  extern char *my_endbss_static;
	  unsigned long my_old_size;

zerofill_entry_point:
          my_old_size = 0UL;

          /* dummy: */
          if ((header_offset >= my_old_size)
              && (old_file_offset >= my_old_size)
              && (sect_type != S_ZEROFILL))
            {
              print_regions();
            }

	  sectp->flags = S_REGULAR;

	  if (strncmp(sectp->sectname, SECT_BSS, (size_t)16UL) == 0) {
	    extern char *my_endbss_static;
	    unsigned long my_new_size;

	    /* Clear uninitialized local variables in statically linked
	       libraries.  In particular, function pointers stored by
	       libSystemStub.a, which is introduced in Mac OS X 10.4 for
	       binary compatibility with respect to long double, are
	       cleared so that they will be reinitialized when the
	       dumped binary is executed on other versions of OS.  */
	    my_new_size = ((unsigned long)my_endbss_static - sectp->addr);
	    if (!((sectp->addr <= (unsigned long)my_endbss_static)
		  && (my_new_size <= sectp->size)))
              {
#if defined(VERBOSE) && VERBOSE
                fprintf(stderr, "my_new_size is %lu; ", my_new_size);
#endif /* VERBOSE */
                unexec_error("my_endbss_static is not in section %.16s",
                             sectp->sectname); /* FIXME(?) */
              }
	    if (!unexec_write((off_t)sectp->offset, (void *)sectp->addr,
                              my_new_size))
	      unexec_error("cannot write section %.16s", sectp->sectname);
	    if (!unexec_write_zero((off_t)(sectp->offset + my_new_size),
				   (sectp->size - my_new_size)))
	      unexec_error("cannot write section %.16s", sectp->sectname);
	    if (!unexec_write((off_t)header_offset, sectp,
                              sizeof(struct section)))
	      unexec_error("cannot write section %.16s's header",
                           sectp->sectname);
	    printf("copying SECT_BSS\n");
	  } else {
	    if (!unexec_write((off_t)sectp->offset, (void *)sectp->addr,
                              sectp->size))
	      unexec_error("cannot write section %s", sectp->sectname);
	    if (!unexec_write((off_t)header_offset, sectp,
                              sizeof(struct section)))
	      unexec_error("cannot write section %s's header",
                           sectp->sectname);
#if defined(VERBOSE) && (VERBOSE > 1)
	    printf("copying %s\n", sectp->sectname);
#endif /* VERBOSE > 1 */
	  }
	}
      else if ((strncmp(sectp->sectname, "__bss", 5UL) == 0)
               || (strncmp(sectp->sectname, "__pu_bss", 8UL) == 0))
        {
          sectp->flags = S_REGULAR;

          /* These sections are produced by GCC 4.6+.

             FIXME: We possibly ought to clear uninitialized local
             variables in statically linked libraries like for
             SECT_BSS (__bss) above, but setting up the markers we
             need in lastfile.c would be rather messy. See
             darwin_output_aligned_bss() in gcc/config/darwin.c for
             the root of the problem, keeping in mind that the
             sections are numbered by their alignment in GCC 4.6, but
             by log2(alignment) in GCC 4.7. */

          if (!unexec_write((off_t)sectp->offset, (void *)sectp->addr,
                            sectp->size))
            unexec_error("cannot copy section %.16s", sectp->sectname);
          if (!unexec_write((off_t)header_offset, sectp,
                            sizeof(struct section)))
            unexec_error("cannot write section %.16s's header",
                         sectp->sectname);
        }
      else if ((strncmp(sectp->sectname, "__la_symbol_ptr", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__nl_symbol_ptr", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__got", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__la_sym_ptr2", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__dyld", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__const", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__cfstring", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__gcc_except_tab", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__program_vars", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__mod_init_func", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__mod_term_func", 16UL) == 0)
               || (strncmp(sectp->sectname, "__static_data", 16UL) == 0)
	       || (strncmp(sectp->sectname, "__objc_", 7UL) == 0))
	{
	  if (!unexec_copy((off_t)sectp->offset, (off_t)old_file_offset,
                           (ssize_t)sectp->size))
	    unexec_error("cannot copy section %.16s", sectp->sectname);
	  if (!unexec_write((off_t)header_offset, sectp,
                            sizeof(struct section)))
	    unexec_error("cannot write section %.16s's header",
                         sectp->sectname);
	}
      else
        {
failure_spot:
          unexec_error("unrecognized section type '0x%x' '%s' in __DATA segment",
                       sect_type, sectp->sectname);
        }

      printf("        section %-16.16s at %#8lx - %#8lx (sz: %#8lx), with type 0x%02x (%s)\n",
	     sectp->sectname, (unsigned long)(sectp->offset),
	     (unsigned long)(sectp->offset + sectp->size),
             (unsigned long)(sectp->size), sect_type,
             strsecttype((int)sect_type));

      header_offset += sizeof(struct section);
      total_size += (uint32_t)sectp->size;
      sectp++;
    }
#if defined(VERBOSE) && VERBOSE
  printf("Section sizes in this segment added up to %#8lx, which is %s its vmsize of %#8lx.\n",
         (unsigned long)total_size,
         ((total_size < scp->vmsize)
          ? "less than"
          : ((total_size > scp->vmsize)
             ? "greater than"
             : "equal to")),
         (unsigned long)scp->vmsize);
#endif /* VERBOSE */

  assert(scp->vmsize >= total_size);

  curr_file_offset += ROUNDUP_TO_PAGE_BOUNDARY(scp->filesize);

  if (!unexec_write((off_t)curr_header_offset, scp,
                    sizeof(struct segment_command)))
    unexec_error("cannot write header of __DATA segment");

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  curr_header_offset += lc->cmdsize;

  /* Create new __DATA segment load commands for regions on the region
   * list that do not corresponding to any segment load commands in
   * the input file: */
  total = 0L;
  for (j = 0U; (j < (uint32_t)num_unexec_regions) && (j < UINT_MAX); j++)
    {
      struct segment_command sc;

      sc.cmd = LC_SEGMENT;
      sc.cmdsize = sizeof(struct segment_command);
      strncpy(sc.segname, SEG_DATA, (size_t)16UL);
      sc.vmaddr = unexec_regions[j].range.address;
      sc.vmsize = unexec_regions[j].range.size;
      sc.fileoff = curr_file_offset;
      sc.filesize = unexec_regions[j].filesize;
      sc.maxprot = (VM_PROT_READ | VM_PROT_WRITE);
      sc.initprot = (VM_PROT_READ | VM_PROT_WRITE);
      sc.nsects = 0;
      sc.flags = 0;
      total = (long)(total + (long)sc.filesize);

#if defined(VERBOSE) && (VERBOSE > 1)
      printf("Writing ");
      print_load_command_name((long)sc.cmd);
      /* leave off the ++nlc_written here, because these were never in the
       * original input file: */
      printf(" \t\tcommand (extra)\n");
#endif /* VERBOSE > 1 */

      printf("Writing segment %-16.16s @ %#9lx (%#8lx/%#11lx @ %#11lx)\n",
	     sc.segname, (unsigned long)(sc.fileoff),
             (unsigned long)(sc.filesize), (unsigned long)(sc.vmsize),
             (unsigned long)(sc.vmaddr));

      if (!unexec_write((off_t)sc.fileoff, (void *)sc.vmaddr, sc.filesize))
        unexec_error("cannot write new __DATA segment %#8lx (sz: %#8lx)",
                     (unsigned long)sc.vmaddr, (unsigned long)sc.filesize);
      curr_file_offset += ROUNDUP_TO_PAGE_BOUNDARY(sc.filesize);

      if (!unexec_write((off_t)curr_header_offset, &sc,
                        (size_t)sc.cmdsize))
	unexec_error("cannot write new __DATA segment's header");
      curr_header_offset += sc.cmdsize;
      mh.ncmds++;
    }
  printf("Total filesize of new __DATA segments written: %ld\n", total);
}

/* Copy a LC_SYMTAB load command from the input file to the output
   file, adjusting the file offset fields.  */
static void
copy_symtab(struct load_command *lc, long delta)
{
  struct symtab_command *stp = (struct symtab_command *)lc;

  stp->symoff += (uint32_t)delta;
  stp->stroff += (uint32_t)delta;

  printf("Writing LC_SYMTAB                      \t\tcommand (%2d)\n",
         ++nlc_written);

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write symtab command to header");

  curr_header_offset += lc->cmdsize;
}

/* Copy a LC_DYLD_INFO_ONLY load command from the input file to the output
   file, adjusting the file offset fields.  */
static void ATTRIBUTE_USED
copy_dyld_info_only(struct load_command *lc, long delta)
{
#ifdef LC_DYLD_INFO_ONLY
  struct dyld_info_command *dyld = (struct dyld_info_command *)lc;

  if (dyld->rebase_size)
    dyld->rebase_off += (uint32_t)delta;
  if (dyld->bind_size)
    dyld->bind_off += (uint32_t)delta;
  if (dyld->weak_bind_size)
    dyld->weak_bind_off += (uint32_t)delta;
  if (dyld->lazy_bind_size)
    dyld->lazy_bind_off += (uint32_t)delta;
  if (dyld->export_size)
    dyld->export_off += (uint32_t)delta;

  printf("Writing ");
  print_load_command_name((long)lc->cmd);
  printf(" \t\tcommand (%2d)\n", ++nlc_written);

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write LC_DYLD_INFO_ONLY command to header");
#else
  unexec_error("How did we get passed this LC_DYLD_INFO_ONLY command?");
#endif /* LC_DYLD_INFO_ONLY */

  curr_header_offset += lc->cmdsize;
}

/* Fix up relocation entries: */
static void
unrelocate(const char *name, off_t reloff, int nrel, vm_address_t base)
{
  int i, unreloc_count;
  struct relocation_info reloc_info;
  struct scattered_relocation_info *sc_reloc_info
    = (struct scattered_relocation_info *)&reloc_info;
  vm_address_t location;

  for (unreloc_count = 0, i = 0; i < nrel; i++)
    {
      if (lseek(infd, reloff, L_SET) != reloff)
	unexec_error("unrelocate: %s:%d cannot seek to reloc_info",
                     name, i);
      if (!unexec_read(&reloc_info, sizeof(reloc_info)))
	unexec_error("unrelocate: %s:%d cannot read reloc_info", name, i);
      reloff += (off_t)sizeof(reloc_info);

      if (sc_reloc_info->r_scattered == 0)
	switch (reloc_info.r_type)
	  {
	  case GENERIC_RELOC_VANILLA:
	    location = (base + (vm_address_t)reloc_info.r_address);
	    if ((location >= data_segment_scp->vmaddr)
		&& (location < (data_segment_scp->vmaddr
                                + data_segment_scp->vmsize)))
	      {
		off_t src_off = (data_segment_old_fileoff
                                 + (off_t)(location
                                           - data_segment_scp->vmaddr));
		off_t dst_off =
                  (off_t)(data_segment_scp->fileoff
                          + (uint32_t)(location
                                       - data_segment_scp->vmaddr));

		if (!unexec_copy(dst_off, src_off,
                                 (ssize_t)(1L << reloc_info.r_length)))
		  unexec_error("unrelocate: %s:%d cannot copy original value",
                               name, i);
		unreloc_count++;
	      }
	    break;
	  default:
	    unexec_error("unrelocate: %s:%d cannot handle type = %d",
			 name, i, reloc_info.r_type);
	  }
      else
	switch (sc_reloc_info->r_type)
	  {
#if defined(__ppc__)
	  case PPC_RELOC_PB_LA_PTR:
	    /* (nothing to do for prebound lazy pointer) */
	    break;
#endif /* __ppc__ */
	  default:
	    unexec_error("unrelocate: %s:%d cannot handle scattered type = %d",
			 name, i, sc_reloc_info->r_type);
	  }
    }

  if (nrel > 0)
    printf("Fixed up %d/%d %s relocation entries in data segment.\n",
	   unreloc_count, nrel, name);
}

#if defined(__ppc64__) && __ppc64__
/* Rebase r_address in the relocation table.  */
static void
rebase_reloc_address(off_t reloff, int nrel, long linkedit_delta, long diff)
{
  int i;
  struct relocation_info reloc_info;
  struct scattered_relocation_info *sc_reloc_info
    = (struct scattered_relocation_info *)&reloc_info;

  for (i = 0; i < nrel; i++, reloff += sizeof(reloc_info))
    {
      if (lseek(infd, (reloff - linkedit_delta), L_SET)
	  != (reloff - linkedit_delta))
	unexec_error("rebase_reloc_table: cannot seek to reloc_info");
      if (!unexec_read(&reloc_info, sizeof(reloc_info)))
	unexec_error("rebase_reloc_table: cannot read reloc_info");

      if ((sc_reloc_info->r_scattered == 0)
	  && (reloc_info.r_type == GENERIC_RELOC_VANILLA))
	{
	  reloc_info.r_address -= diff;
	  if (!unexec_write(reloff, &reloc_info, sizeof(reloc_info)))
	    unexec_error("rebase_reloc_table: cannot write reloc_info");
	}
    }
}
#endif /* __ppc64__ */

/* Copy a LC_DYSYMTAB load command from the input file to the output
   file, adjusting the file offset fields.  */
static void
copy_dysymtab(struct load_command *lc, long delta)
{
  struct dysymtab_command *dstp = (struct dysymtab_command *)lc;
  vm_address_t base;

#ifdef _LP64
# if defined(__ppc64__) && __ppc64__
  {
    int i;

    base = 0;
    for (i = 0; i < nlc; i++)
      if (lca[i]->cmd == LC_SEGMENT)
	{
	  struct segment_command *scp = (struct segment_command *)lca[i];

	  if (((scp->vmaddr + scp->vmsize) > 0x100000000)
	      && ((scp->initprot & VM_PROT_WRITE) != 0))
	    {
	      base = data_segment_scp->vmaddr;
	      break;
	    }
	}
  }
# else
  /* First writable segment address.  */
  base = data_segment_scp->vmaddr;
# endif /* __ppc64__ */
#else
  /* First segment address in the file (unless MH_SPLIT_SEGS set). */
  base = 0;
#endif /* _LP64 */

  unrelocate("local", (off_t)dstp->locreloff, (int)dstp->nlocrel, base);
  unrelocate("external", (off_t)dstp->extreloff, (int)dstp->nextrel, base);

  if (dstp->nextrel > 0) {
    dstp->extreloff += (uint32_t)delta;
  }

  if (dstp->nlocrel > 0) {
    dstp->locreloff += (uint32_t)delta;
  }

  if (dstp->nindirectsyms > 0)
    dstp->indirectsymoff += (uint32_t)delta;

  printf("Writing LC_DYSYMTAB                    \t\tcommand (%2d)\n",
         ++nlc_written);

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write symtab command to header");

  curr_header_offset += lc->cmdsize;

#if defined(__ppc64__) && __ppc64__
  /* Check if the relocation base needs to be changed.  */
  if (base == 0)
    {
      vm_address_t newbase = 0;
      int i;

      for (i = 0; i < num_unexec_regions; i++)
	if (unexec_regions[i].range.address + unexec_regions[i].range.size
	    > 0x100000000)
	  {
	    newbase = data_segment_scp->vmaddr;
	    break;
	  }

      if (newbase)
	{
	  rebase_reloc_address(dstp->locreloff, dstp->nlocrel, delta, newbase);
	  rebase_reloc_address(dstp->extreloff, dstp->nextrel, delta, newbase);
	}
    }
#endif /* __ppc64__ */
}

/* Copy a LC_TWOLEVEL_HINTS load command from the input file to the output
   file, adjusting the file offset fields.  */
static void
copy_twolevelhints(struct load_command *lc, long delta)
{
  struct twolevel_hints_command *tlhp = (struct twolevel_hints_command*)lc;

  if (tlhp->nhints > 0) {
    tlhp->offset += (uint32_t)delta;
  }

  printf("Writing LC_TWOLEVEL_HINTS \t\tcommand (%2d)\n", ++nlc_written);

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write two level hint command to header");

  curr_header_offset += lc->cmdsize;
}

#ifdef LC_DYLD_INFO
/* Copy a LC_DYLD_INFO(_ONLY) load command from the input file to the output
   file, adjusting the file offset fields.  */
static void
copy_dyld_info(struct load_command *lc, long delta)
{
  struct dyld_info_command *dip = (struct dyld_info_command *)lc;

  if (dip->rebase_off > 0)
    dip->rebase_off += (uint32_t)delta;
  if (dip->bind_off > 0)
    dip->bind_off += (uint32_t)delta;
  if (dip->weak_bind_off > 0)
    dip->weak_bind_off += (uint32_t)delta;
  if (dip->lazy_bind_off > 0)
    dip->lazy_bind_off += (uint32_t)delta;
  if (dip->export_off > 0)
    dip->export_off += (uint32_t)delta;

  printf("Writing ");
  print_load_command_name((long)lc->cmd);
  printf(" \t\tcommand (%2d)\n", ++nlc_written);

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write dyld info command to header");

  curr_header_offset += lc->cmdsize;
}
#endif /* LC_DYLD_INFO */

#ifdef LC_FUNCTION_STARTS
/* Copy a LC_FUNCTION_STARTS/LC_DATA_IN_CODE/LC_DYLIB_CODE_SIGN_DRS
   load command from the input file to the output file, adjusting the
   data offset field.  */
static void
copy_linkedit_data(struct load_command *lc, long delta)
{
  struct linkedit_data_command *ldp = (struct linkedit_data_command *)lc;

  if (ldp->dataoff > 0)
    ldp->dataoff += (uint32_t)delta;

  printf("Writing ");
  print_load_command_name((long)lc->cmd);
  /* FIXME: hackish; see note about hardcoding print widths above: */
  if (lc->cmd == LC_FUNCTION_STARTS) {
    printf(" \tcommand (%2d)\n", ++nlc_written);
  } else {
    printf(" \t\tcommand (%2d)\n", ++nlc_written);
  }

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write linkedit data command to header");

  curr_header_offset += lc->cmdsize;
}
#endif /* LC_FUNCTION_STARTS */

/* Copy other kinds of load commands from the input file to the output
   file, ones that do not require adjustments of file offsets.  */
static void
copy_other(struct load_command *lc)
{
  printf("Writing ");
  print_load_command_name((long)lc->cmd);
  /* FIXME: hackish; see note about hardcoding print widths above: */
#ifdef LC_VERSION_MIN_MACOSX
  if (lc->cmd == LC_VERSION_MIN_MACOSX)
    {
      printf(" \tcommand (%2d)\n", ++nlc_written);
    }
  else
#endif /* LC_VERSION_MIN_MACOSX */
    {
      printf(" \t\tcommand (%2d)\n", ++nlc_written);
    }

  if (lc->cmd == LC_CODE_SIGNATURE)
    lc->cmd = 0x0;		/* Do NOT propagate signature */

#ifdef __LP64__
  assert((lc->cmdsize % 8) == 0);
#else
  assert((lc->cmdsize % 4) == 0);
#endif /* __LP64__ */

  if (!unexec_write((off_t)curr_header_offset, lc, (size_t)lc->cmdsize))
    unexec_error("cannot write symtab command to header");

  curr_header_offset += lc->cmdsize;
}

/* Loop through all load commands and dump them.  Then write the Mach
   header.  */
static void
dump_it(void)
{
  int i;
  long linkedit_delta = 0L;

  printf("--- Load Commands written to Output File ---\n");

  for (i = 0; i < nlc; i++)
    switch (lca[i]->cmd)
      {
      case LC_SEGMENT:
	{
	  struct segment_command *scp = (struct segment_command *)lca[i];
	  if (strncmp(scp->segname, SEG_DATA, (size_t)16UL) == 0)
	    {
	      /* save data segment file offset and segment_command for
		 unrelocate */
	      if (data_segment_old_fileoff)
		unexec_error("cannot handle multiple DATA segments"
			     " in input file");
	      data_segment_old_fileoff = (off_t)scp->fileoff;
	      data_segment_scp = scp;

	      copy_data_segment(lca[i]);
	    }
	  else
	    {
	      if (strncmp(scp->segname, SEG_LINKEDIT, (size_t)16UL) == 0)
		{
		  if (linkedit_delta)
		    unexec_error("cannot handle multiple LINKEDIT segments"
				 " in input file");
		  linkedit_delta = (long)(curr_file_offset - scp->fileoff);
		}

	      copy_segment(lca[i]);
	    }
	}
	break;
      case LC_SYMTAB:
	copy_symtab(lca[i], linkedit_delta);
	break;
      case LC_DYSYMTAB:
	copy_dysymtab(lca[i], linkedit_delta);
	break;
      case LC_TWOLEVEL_HINTS:
	copy_twolevelhints(lca[i], linkedit_delta);
	break;
#ifdef LC_DYLD_INFO
      case LC_DYLD_INFO:
        copy_dyld_info(lca[i], linkedit_delta);
        break;
      case LC_DYLD_INFO_ONLY:
	copy_dyld_info_only(lca[i], linkedit_delta);
	break;
#endif /* LC_DYLD_INFO */
      case LC_CODE_SIGNATURE:
      case LC_SEGMENT_SPLIT_INFO:
#ifdef LC_FUNCTION_STARTS
      case LC_FUNCTION_STARTS:
# ifdef LC_DATA_IN_CODE
      case LC_DATA_IN_CODE:
# endif /* LC_DATA_IN_CODE */
# ifdef LC_DYLIB_CODE_SIGN_DRS
      case LC_DYLIB_CODE_SIGN_DRS:
# endif /* LC_DYLIB_CODE_SIGN_DRS */
	copy_linkedit_data(lca[i], linkedit_delta);
	break;
#endif /* LC_FUNCTION_STARTS */
      default:
	copy_other(lca[i]);
	break;
      }

  if (curr_header_offset > text_seg_lowest_offset) {
    unexec_error("not enough room for load commands for new __DATA segments"
                 " (increase headerpad_extra in configure.ac to at least %lX)",
                 ((size_t)num_unexec_regions * sizeof(struct segment_command)));
  }

  printf("%lu unused bytes follow Mach-O header\n",
	 (text_seg_lowest_offset - curr_header_offset));

  mh.sizeofcmds = (uint32_t)(curr_header_offset
                             - sizeof(struct mach_header));
  if (!unexec_write((off_t)0L, &mh, sizeof(struct mach_header)))
    unexec_error("cannot write final header contents");

  if (nlc != nlc_written) {
    fprintf(stderr, "Warning: Mismatch between number of load commands written (%d) vs. expected (%d)\n",
            nlc_written, nlc);
  }
}

/* Take a snapshot of Emacs and make a Mach-O format executable file
   from it.  The file names of the output and input files are outfile
   and infile, respectively.  The three other parameters are
   ignored.  */
void
unexec(const char *outfile, const char *infile)
{
  if (in_dumped_exec)
    unexec_error("Unexec from a dumped executable is not supported.");

  pagesize = (unsigned long)getpagesize();
  infd = emacs_open(infile, O_RDONLY, 0);
  if (infd < 0)
    {
      unexec_error("cannot open input file `%s'", infile);
    }

  outfd = emacs_open(outfile, (O_WRONLY | O_TRUNC | O_CREAT), 0777);
  if (outfd < 0)
    {
      emacs_close(infd);
      unexec_error("cannot open output file `%s'", outfile);
    }

  build_region_list();
  read_load_commands();

  find_emacs_zone_regions();
  unexec_regions_merge();

  in_dumped_exec = 1;

  dump_it();

  emacs_close(outfd);
}


void unexec_init_emacs_zone(void)
{
  emacs_zone = malloc_create_zone((vm_size_t)0, 0);
  malloc_set_zone_name(emacs_zone, "EmacsZone");
  check_emacs_zone();
}

#ifndef MACOSX_MALLOC_MULT16
# define MACOSX_MALLOC_MULT16 1
#endif /* !MACOSX_MALLOC_MULT16 */

typedef struct unexec_malloc_header {
  union {
    char c[8];
    size_t size;
  } u;
} unexec_malloc_header_t;

#if MACOSX_MALLOC_MULT16
# define ptr_in_unexec_regions(p) ((((vm_address_t)(p)) & 8) != 0)
#else
int ptr_in_unexec_regions(void *ptr)
{
  int i;

  for (i = 0; i < num_unexec_regions; i++)
    if (((vm_address_t)ptr - unexec_regions[i].range.address)
	< unexec_regions[i].range.size)
      return 1;

  return 0;
}
#endif /* MACOSX_MALLOC_MULT16 */

void *unexec_malloc(size_t size)
{
  if (in_dumped_exec)
    {
      void *p;

      p = malloc(size);
#if MACOSX_MALLOC_MULT16
      assert(((vm_address_t)p % 16) == 0);
#endif /* MACOSX_MALLOC_MULT16 */
      return p;
    }
  else
    {
      unexec_malloc_header_t *ptr;

      check_emacs_zone();

      ptr =
        ((unexec_malloc_header_t *)
         malloc_zone_malloc(emacs_zone,
                            (size + sizeof(unexec_malloc_header_t))));

      check_emacs_zone();

      ptr->u.size = size;
      ptr++;
#if MACOSX_MALLOC_MULT16
      assert(((vm_address_t)ptr % 16) == 8);
#endif /* MACOSX_MALLOC_MULT16 */
      return (void *)ptr;
    }
}

void *unexec_realloc(void *old_ptr, size_t new_size)
{
  if (in_dumped_exec)
    {
      void *p;

      if (ptr_in_unexec_regions(old_ptr))
	{
	  size_t old_size = ((unexec_malloc_header_t *)old_ptr)[-1].u.size;
	  size_t size = ((new_size > old_size) ? old_size : new_size);

#ifdef __cplusplus
	  p = (size_t *)malloc(new_size);
#else
          p = malloc(new_size);
#endif /* __cplusplus */
	  if (size)
	    memcpy(p, old_ptr, size);
	}
      else
	{
	  p = realloc(old_ptr, new_size);
	}
#if MACOSX_MALLOC_MULT16
      assert(((vm_address_t)p % 16) == 0);
#endif /* MACOSX_MALLOC_MULT16 */
      return p;
    }
  else
    {
      unexec_malloc_header_t *ptr;

      check_emacs_zone();

      ptr =
        ((unexec_malloc_header_t *)
         malloc_zone_realloc(emacs_zone,
                             ((unexec_malloc_header_t *)old_ptr - 1),
                             (new_size + sizeof(unexec_malloc_header_t))));

      check_emacs_zone();

      ptr->u.size = new_size;
      ptr++;
#if MACOSX_MALLOC_MULT16
      assert(((vm_address_t)ptr % 16) == 8);
#endif /* MACOSX_MALLOC_MULT16 */
      return (void *)ptr;
    }
}

void unexec_free(void *ptr)
{
  if (ptr == NULL)
    return;
  if (in_dumped_exec)
    {
      if (!ptr_in_unexec_regions(ptr))
	free(ptr);
    }
  else
    {
      check_emacs_zone();
      malloc_zone_free(emacs_zone, ((unexec_malloc_header_t *)ptr - 1));
    }
}

/* arch-tag: 1a784f7b-a184-4c4f-9544-da8619593d72
   (do not change this comment) */
